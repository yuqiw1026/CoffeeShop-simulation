# CoffeeShop-simulation

# **Introduction**
This project simulated the basic operation process of a certain coffee shop and the purpose is to decide number of cashiers need to be hired in order to maximize the the net profit. An event-driven simulation is where the program processes events as in the order of time. The event-driven simulation is implemented through the use of data structures of Priority Queue, Queue, ArrayDeque, ArrayList and LinkedList. The LinkedList and the ArrayDeque are implemented through the Queue interface and their performances are compared. The data from the coffee shop to be analyzed are taken and read from a given input file. 
# **Approach**

This simulation is implemented through seven classes. First, the Event class creates events that were either labelled as ARRIVAL or DEPARTURE. The event object also stores the customer number and the time of the event (either arrival or departure) The event objects are comparable by the time of the event so that the events can be used in a priority queue.
Second, the Customer class created customer objects that stored the customer number, the arrival time of the customer, the departure time of the customer, how long the customer waited to be served (in the queue and at the counter), and the profit generated from the customer.

The main class of the program was the Simulation class. This is where the event-driven simulation occurred. The user specifies the number of baristas as one of the instance variables of this class and also specifies whether a LinkedList or an ArrayDeque is to be used as the customerLine Queue, which is the queue where the customers wait in the store. A queue was chosen because the customers are to be served on a first-in-first-out basis. When the program runs, the first thing that happens is the input file, “input.txt,” is read using the Scanner and File classes. The parameters of profit limits, time limits, and barista cost are filled from the input file Also, each arrival time read from the input file and converted to an instance of the LocalTimeClass. For each arrival time, a new Event is created with the arrival time and inserted to the eventSet PriorityQueue. A PriorityQueue was chosen because then the events would be processed in order of time. Additionally, for each arrival time, a new Customer is created and inserted into the customerRecords ArrayList. A Customer’s instance variables are updated as the customer is served. Therefore, at the end of the program’s run, the customerRecords is an accurate record of each customer’s visit.

After the input file is read, the Events in the PriorityQueue are processed. For every arrival event, if there is room in the queue then they join the customerLine queue, otherwise, they immediately depart, the corresponding Customer in customerRecords is updated accordingly, and the totalNumberOverflowed counter increments by one. If they were able to join the queue, then the Customer was given a randomly generated profit and counter serving time. The profits are randomly generated using ThreadLocalRandom. People are served in a first-in-first-out fashion from the customerLine. If there was an available barista, then they were served immediately, so their departure time was simply their arrival time plus their counter serving time, and their total wait time was their arrival time minus their departure time, as calculated using Duration. However, if they had to wait in the customerLine Queue, then they were served once a departure event was processed and a barista became available. Thus, their departure time was the departure time of the last Customer plus their counter serving time, and their total wait time was their arrival time minus their departure time.

Finally, the specified statistics (the amount of daily net profit, the percentage of overflow, and the average and maximum waiting time of all customers served) are computed and printed to the terminal window. The daily profit was calculated by subtracting the cost of a barista multiplied by the number of baristas from the totalProfit (a running total of profits from each customer). The percentage of overflow was computed by dividing the totalNumberOverflowed by the customerNumber and multiplying by 100. The max time a customer had to wait was found by iterating through the customerRecords and the average time a customer had to wait was found by iterating through the customerRecords, keeping a running total of time waited, and dividing by the customerNumber.

# **General Running Instructions**
The project was created and should be run in BlueJ.
